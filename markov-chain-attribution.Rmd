---
title: "Markov Model Attribution"
author: "Sean Astrup - seanastrup@gmail.com"
runtime: shiny
css: www/my.css
output: 
  html_notebook:
    code_folding: hide
---

####Post in progress. Stable development release updated on: 2018-10-10

##Markov multi-channel conversion *(or any!)* rate optimization
I may do a follow-up or expansion to this on *why* multi-channel funnel optimization is important as well as a deeper explanation of the methods and models used. For now, this tool may be useful to those analysts or campaign managers with a general understanding of *at least* what markov chains are as well as their place in an overall multi-channel optimization strategy.

```{r echo=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)
library(DT)
library(googleAnalyticsR)
library(googleAuthR)
library(ChannelAttribution)
library(highcharter)
source('ga-auth.R')
```

```{r ga_auth, echo=FALSE}

googleAuthUI("auth")
token  <- callModule(googleAuth, "auth")

###################################################
########## VIEW ID SELECTION CONTROLS #############
###################################################
  ga_accounts <- reactive({
    
    req(token())
    
    with_shiny(ga_account_list, shiny_access_token = token())
    
  })
  
  # selected_id <- callModule(authDropdown, 'auth_menu', ga.table = ga_accounts)
  
  AccountTable <- reactive({
    
    ga_accounts()
    
  })
  
  pList <- reactive({
    
    ga.table <- ga_accounts()
    
    ga.table[,c('accountName','webPropertyId','websiteUrl','viewName', 'viewId')]
    
  })
  
  ##############################
  ### UPDATE SELECTION VALUES ##
  ##############################
  observe({
    
    validate(
      need(pList(), "Need profiles")
    )
    
    pList  <- pList()
    
    AccountChoices <- unique(pList$accountName)
    
    updateSelectizeInput(session, 
                      "Accounts",
                      label = "Accounts",
                      choices = AccountChoices, 
                      selected = AccountChoices[1],
                      server = TRUE)
    
  })
  
  observe({
      
      validate(
        need(input$Accounts, "Need accounts")
      )
      pList  <- pList()
      
      pList <- pList[input$Accounts == pList$accountName,]
      
      PropertyChoices <- pList$websiteUrl
      
      updateSelectizeInput(session, 
                        "Properties", label="Properties",
                        choices = PropertyChoices, 
                        selected = PropertyChoices[1],
                        server = TRUE)
    
    })
  
  observe({
    
    validate(
      need(input$Properties, "Need web")
    )
    
    pList <- pList()
    
    pList <- pList[input$Properties == pList$websiteUrl,]
    
    ViewChoices <- pList$viewId 
    
    names(ViewChoices) <- paste(pList$viewName, pList$viewId)
    
    updateSelectizeInput(session, 
                         "Views", label = "Views",
                         choices = ViewChoices, 
                         selected = ViewChoices[1],
                         server = TRUE)
  })
  
  # observe({
  #   
  #   
  #   
  # })
  
  GaAccount <- reactive({
    
    validate(
      need(pList(), "Need profiles")
    )
    
    pList  <- pList()
    
    out <- unique(pList$accountName)
    
    return(out[1])
    
  })
  GaProperty <- reactive({
    
    validate(
      need(input$Properties, "Please login")
    )
    
    pList <- pList()
    out <- pList[input$Accounts == pList$accountName,]
    
    return(out$websiteUrl)
    
  })
  GaView <- reactive({
    
    validate(
      need(input$Views, "Please login")
    )
    pList <- pList()
    
    out <- pList[input$Views == pList$viewId,]
    
    return(out$viewId)
    
  })
  
  # GoalsList <- reactive({
  # 
  #   validate(
  #     need(input$Views, "Please login")
  #   )
  # 
  #   Account <- GaAccount()
  #   Property <- GaProperty()
  #   View <- GaView()
  # 
  #   Goals <- with_shiny(ga_goal_list,
  #                       Account, 
  #                       Property, 
  #                       View, 
  #                       shiny_access_token = token())
  #   
  #   return(Goals)
  # 
  # })
  
```

```{r echo=FALSE}
shiny::inputPanel(
  shiny::selectizeInput(inputId = 'Accounts', label = 'Accounts', choices = NULL),
  shiny::selectizeInput(inputId = 'Properties', label = 'Properties', choices = NULL),
  shiny::selectizeInput(inputId = 'Views', label = 'Views', choices = NULL)
)
```


```{r}
get_device_sessions <- reactive({
    
    req(GaView())
    gaid <- GaView()
    with_shiny(google_analytics,
               viewId = gaid,
               date_range = c(lubridate::today() - 120, lubridate::today()),
               metrics = c('sessions'),
               dimensions = c('date', 'deviceCategory'),
               shiny_access_token = token())
    
  })

get_total_sessions <- reactive({
  
  req(GaView())
  gaid <- GaView()
  Sessions <- 
    with_shiny(google_analytics_3,
               id = gaid,
               start = lubridate::today() - 120, 
               end =  lubridate::today(),
               metrics = c('totalConversions'),
               dimensions = c('sourceMediumPath'),
               type = 'mcf',
               filters = 'mcf:conversionGoalNumber==001', 
               shiny_access_token = token()
               )
  names(Sessions) <- c('SourceMediumPath','sessions')
  
  # Clean junk from results 
  Sessions$SourceMediumPath <- gsub(" / ", "/", Sessions[,1])              
  Sessions$SourceMediumPath <- gsub(":?(NA|CLICK|NA):?", "", Sessions[,1]) 
  Sessions$SourceMediumPath <- as.numeric(Sessions[,2]) 
  
  Sessions$sessions <- sample(3000, size = nrow(Sessions), replace = TRUE)     # random noise for dev
  
  return(Sessions)
  
})

get_total_conversions <- reactive({
  
  req(GaView())
  gaid <- GaView()
  Conversions <- 
    with_shiny(google_analytics_3,
               id = gaid,
               start = lubridate::today() - 120, 
               end =  lubridate::today(),
               metrics = c('totalConversions'),
               dimensions = c('sourceMediumPath'),
               type = 'mcf',
               filters = 'mcf:conversionType==Transaction',
               shiny_access_token = token()
               )
    
  names(Conversions) <- c('SourceMediumPath', 'transactions')
  
  # Clean junk from results 
  Conversions$sourceMedium <- gsub(" / ", "/", Conversions[,1])              
  Conversions$sourceMedium <- gsub(":?(NA|CLICK|NA):?", "", Conversions[,1]) 
  Conversions$sourceMedium <- as.numeric(Conversions[,2]) 
  Conversions$transactions <- Conversions$transactions %>% replace_na(0)
    
  Conversions$transactions <- sample(100, size = nrow(Conversions), replace = TRUE)  # random noise for dev
  
  return(Conversions)
  
})

make_total_data <- reactive({
  
  Conversions <- get_total_conversions()
  Sessions <- get_total_sessions()
  
  Data <- full_join(Conversions, Sessions, by = 'SourceMediumPath')
  
  Data <- 
    Data %>% 
    mutate(ConversionRate = ifelse(transactions == 0, 0, transactions / sessions))
  
  return(Data)
  
})

MarkovModel <- reactive({
  
  Data <- make_total_data()
  
  Model <- ChannelAttribution::markov_model(Data, var_path = 'sourceMedium', 
                                            var_conv = 'transactions',
                                            var_null = 'null', 
                                            order = 1, nsim = NULL, 
                                            max_step = NULL, out_more = FALSE)
  
  return(Model)
  
})

HeuristicModel <- reactive({
  
  Data <- make_total_data()
  
  Model <- ChannelAttribution::heuristic_models(Data, var_path = 'sourceMedium', 
                                                var_conv = 'transactions', 
                                                order = 1, nsim = NULL, 
                                                max_step = NULL, out_more = FALSE)
  
  return(Model)
  
})

ModeledData <- reactive({
  
  MarkovModel <- MarkovModel()
  HeuristicModel <- HeuristicModel()
  
  ModeledData <- full_join(MarkovModel, HeuristicModel, by = 'sourceMedium')
  
})

# shiny::renderText({class(GoalsList())})

A <- renderTable({get_total_sessions()})
B <- renderTable(({get_total_conversions()}))
A
B


# DailyDeviceSessions <- renderHighchart({
#     
#     # only trigger once authenticated
#     req(get_device_sessions())
#     
#     gadata <- get_device_sessions()
#     
#     gadata$sessions <- sample(3000, size = nrow(gadata), replace = TRUE)  # random noise for dev
#     
#     hchart(gadata, 'spline' , hcaes(x = date, y = sessions, 
#                                                  group = deviceCategory)) %>%
#       hc_xAxis(
#         title = list( 
#           text = ''
#         )
#       ) %>% 
#       hc_yAxis(
#         title = list( 
#           text = ''
#         )
#       ) %>% 
#       hc_title(text = 'Device Sessions By Date') 
#       
#   })
# TotalConversions <- DT::renderDataTable({
#   
#     TotalConversions <- get_total_conversions() 
#     
#     # TotalConversions$ConversionRate <- scales::percent(TotalConversions$ConversionsRate)
#     TotalConversions %>%
#       datatable(options = list(
#         pageLength = 7, 
#         searching = FALSE
#         )
#       ) %>% 
#       formatCurrency(c('sourceMedium', 'transactions', 'sessions'), '', digits = 0) %>% # format as currency but leave indicator blank. (For big.mark formatting)
#       formatPercentage('ConversionRate', 2)
# 
#   })
# 
# TotalConversions
# DailyDeviceSessions
```

